---
title: Wife's ledger
publishedAt: 2025-06-14
description: A diary about writing a household account book for newlyweds
tags: [â€œmarriageâ€, â€˜pythonâ€™, â€œtipsâ€]
---

Last October, I met the love of my life and got married. At the same time, I was faced with practical issues that I hadn't thought about during our courtship, one of which was **household finances**.

Nine years ago, I got my first job, and I moved out the following year. From then on, I began to realize where my money was going and how much I was spending. Fixed expenses like electricity, gas, and internet bills were adding up, so I couldnâ€™t ignore them anymore.

### In college, my household budget consisted of my debit card statements.

Categories like meals, coffee, and school supplies were simple, so debit card statements were enough. However, as my spending increased and became more complex, it became difficult to categorize each expense. When hanging out with friends for dinner and drinks, is that **food expenses** or **drink expenses**?

Thatâ€™s when I started using the service **Bank Salad**.

![Bank Salad helped me create my household budget back then. It's now famous for its genetic testing service.](/images/screenshot_banksalad.png)

Thanks to Bank Salad, which automatically categorizes my credit card transactions, managing my expenses became easier. I could also set and check budgets.

### Then one day, the Toss Check Card appeared

![My main card, the Toss Check Card](/images/toss-checkcard.png)

I temporarily stopped using Bank Salad after three years because of the Toss Check Card. At the time, there were no performance conditions or annual fees, and you received 300 won in cash back for each payment. You could even eat a Big Mac for less than 5,000 won! However, one problem arose.

> The transactions made with Toss were not visible in Bank Salad.

Toss provided a separate "Spending" screen within its app with a convenient structure for organizing cashback details. At the time, however, Bank Salad had technical limitations when it came to scraping data from other card companies, and Toss did not share information externally. I had no choice but to move my household budget to Toss. However, there was one thing I overlooked.

The Toss Consumption tab did not have the "Download as File" feature that Bank Salad had. I needed this feature because I organize my household budget in Excel every year. I searched through various menus but could not find a way to extract the entire consumption history. My complacent belief that "it must be possible" was the problem.

### So I eventually settled on â€œEasy Ledgerâ€

![The app that takes household budgets seriously, Easy Ledger](/images/screenshot_easy-ledger.png)

This service is simple. **Just copy the text message from the card company and paste it into the app,** and it automatically assigns a name. No manual work is needed for cashback or item classification. You can even automate this process using the iPhoneâ€™s shortcut feature.

## And after marriage, a new category emerged: â€œWife's spending.â€

This transaction history cannot be accessed via MyData or credit card texts. The biggest issue is that even if you receive the information, you can never know why the spending occurred unless you ask directly. If I were to ask my wife, â€œWhy did you buy that?â€ every time she made a purchaseâ€¦ I might be single again by now. Repeated questions are off-limits with my wife. So we made a deal.

> **Investments** are handled by my wife, and **spending management** is handled by me.

My wife bought NVIDIA at the bottom during the pandemic, while I bought a local apartment at the peak and ended up with a 10% loss. It was a natural decision.

### Starting the wife's household budget book

She rotates between five banks and four credit cards to maximize benefits. I downloaded transaction histories and statements from each financial institutionâ€™s website and compiled data from nine institutions into Excel. There were 385 items in total.

Categorizing each item into the 11 major categories and 42 subcategories I created was overwhelming.
Just as I was wondering, "Why am I doing this?" , I encountered Claude.

### I entrusted my household budget to AI

Since my company has been automating many tasks recently, I naturally tried writing a prompt for Claude. I remembered handling data with Python in college, so writing the command wasnâ€™t difficult.

![Code generated from â€œOrganize the consumption records according to my classification criteria file.â€](/images/screenshot_vsc-consumption.png)

The results were astonishing. My Python screen displayed 220 lines of code containing over 500 keyword-matching tables organized in object form.

Thanks to Claude, I no longer have to ask my wife about daily payment details. Now, I have a complete household budget that allows me to view income and expenses at a glance on a quarterly basis.

Finally, Iâ€™ll share the Python code written by Claude. I hope it brings peace to many households.

```
import pandas as pd
import json
import re
from datetime import datetime

def load_classification_rules():
    """ë¶„ë¥˜ê¸°ì¤€.json íŒŒì¼ì„ ë¡œë“œí•©ë‹ˆë‹¤."""
    with open('ë¶„ë¥˜ê¸°ì¤€.json', 'r', encoding='utf-8') as f:
        return json.load(f)

def classify_transaction(merchant, business_type, rules):
    """ê±°ë˜ ë‚´ìš©ì„ ë¶„ì„í•˜ì—¬ ë¶„ë¥˜ì™€ ì†Œë¶„ë¥˜ë¥¼ ê²°ì •í•©ë‹ˆë‹¤."""
    # ê°€ë§¹ì ëª…ê³¼ ì—…ì¢…ì„ ê²°í•©í•´ì„œ ë¶„ì„
    description = f"{merchant} {business_type}".lower() if pd.notna(business_type) else str(merchant).lower()

    # íŠ¹ìˆ˜ë¬¸ì ì œê±°í•˜ë˜ ë” ê´€ëŒ€í•˜ê²Œ
    description_clean = re.sub(r'[^\w\sê°€-í£a-zA-Z0-9()]', ' ', description)
    description_clean = re.sub(r'\s+', ' ', description_clean).strip()


    # íŠ¹ë³„ ì²˜ë¦¬ - ê°€ì¥ ë¨¼ì € ì²˜ë¦¬
    etc = ['ì¹´ì¹´ì˜¤í˜ì´']
    if any(name in description_clean for name in etc):
        return 'ê¸°íƒ€', 'ê¸°íƒ€'


    # ë¨¼ì € ë¶„ë¥˜ê¸°ì¤€.jsonì˜ í‚¤ì›Œë“œë¡œ ë§¤ì¹­
    for category, subcategories in rules.items():
        for subcategory in subcategories:
            if subcategory.lower() in description_clean:
                return category, subcategory

    # ëŒ€í­ í™•ì¥ëœ í‚¤ì›Œë“œ ë§¤ì¹­
    keyword_mapping = {
        'ì‹ë¹„': {
            'ì‹ë£Œí’ˆ': ['ë§ˆíŠ¸', 'ìŠˆí¼ë§ˆì¼“', 'ìŠˆí¼', 'í¸ì˜ì ', 'gs25', 'cu', 'ì„¸ë¸ì¼ë ˆë¸', 'ì´ë§ˆíŠ¸', 'í™ˆí”ŒëŸ¬ìŠ¤', 'ë¡¯ë°ë§ˆíŠ¸', 'gsìˆ˜í¼', 'ï½‡ï½“ìˆ˜í¼', 'ìš°ë¦¬ë§ˆíŠ¸', 'ì´ˆë¡ë§ˆì„', 'ì»¬ë¦¬', 'ë¡¯ë°ìŠˆí¼', 'ë†í˜‘', 'í•œìš°ëª…í’ˆê´€', 'ì§€ì—ìŠ¤25', 'ì§€ì—ìŠ¤', 'ì„¸ë¸', 'ì‚°ì§€ë¬¼ë“ ', 'ë¸Œë ˆë“œ05', 'ì—ì´ì¹˜ë´„', 'ë´„', 'íŠ¹ë³„í•œì„œì¬', 'ì»¬ë¦¬í˜ì´', 'ë² ì´ì»¤ë¦¬', 'ë¹µ', 'ë””ì €íŠ¸', 'ë„ë„›', 'ì œê³¼ì ', 'ì•„ì´ìŠ¤í¬ë¦¼', 'ë‚˜í´ë ˆì˜¹', 'ê³ ë©”ë¸Œë˜ë“œ', 'ê³ ë©”ë¸Œë ˆë“œ', 'ëŸ°ë˜ë² ì´ê¸€', 'ë¸Œë¡œíŠ¸ì•„íŠ¸', 'ë„ì‹œë½', 'ì˜¤ì˜ì£¼', 'íŒŒë¦¬í¬ë¼ìƒ', 'ë‚™ì›ë–¡ì§‘', 'ê³µë£¡ë¹µê³µì¥', 'ë–¡ì§‘', 'ì˜¤ì¡°', 'ë…¸ë¸Œëœë“œ', 'ì„œìš¸í˜ì´', 'ì»¬ë¦¬í˜ì´', 'í•œìš°', 'ê³¶ê°', 'ì ¤ë¼ë–¡','ì˜¨ëˆ„ë¦¬í˜ì´', 'ì”¨ìœ ','í™ˆí‘¸ë“œ','ì²­ê³¼'],
            'ì™¸ì‹': ['ì‹ë‹¹', 'ë ˆìŠ¤í† ë‘', 'ì¤‘ì‹', 'ì¼ì‹', 'ì–‘ì‹', 'í•œì‹', 'ì¹˜í‚¨', 'í”¼ì', 'ë²„ê±°í‚¹', 'ë§¥ë„ë‚ ë“œ', 'kfc', 'ë¡¯ë°ë¦¬ì•„', 'ë°±í™”ì ', 'ê¸°íƒ€ì¼ë°˜ìŒì‹', 'í‘¸ë“œì½”íŠ¸', 'ìŠ¤ì‹œ', 'ë„ë¦¬íƒ•', 'ë‹­ê°ˆë¹„', 'êµ­ìˆ˜', 'ë¼ì§€', 'ìˆ˜ì‚°', 'ëŒ€ê²Œ', 'ê³ ë“±ì–´', 'í•´ì¥êµ­', 'ìœ¡ë¥˜', 'ìƒì„ ', 'íšŒ', 'êµ¬ì´', 'ì°œ', 'ë½', 'ë™ë™êµ­ìˆ˜', 'ì²­ë‹´ë™ìˆœë„ë¦¬', 'í’ë…„ë‹­ë„ë¦¬íƒ•', 'ê²½ë™ìˆ˜ì‚°', 'í¬í•­ëŒ€ê²Œë™ë‚¨ìˆ˜ì‚°', 'ì°©í•œì œì£¼ê³ ë“±ì–´', 'ë¶ì´Œê¹€ì¹˜ì¬', 'ì˜¤ì¿ ë‹¤ê³µí•­ì ', 'ì¥ì›ë¶ì–´êµ­', 'ë¯¸ë¶„ë‹¹', 'ë¼ì¿ ì—”', 'ìµì„ ëˆê¹ŒìŠ¤', 'ìš°ì•„ë™', 'ì‰ì´í¬ì‰‘', 'ë¹…ë°”ì´íŠ¸ì»´í¼ë‹ˆ', 'ì•„ì›Œí™ˆí‘¸ë””ì›€', 'ì—ìŠ¤ì”¨ì¼€ì´', 'ì§¬ë½•', 'ëƒ‰ë©´', 'ì¡±ë°œ', 'ë³´ìŒˆ', 'ê³±ì°½', 'ìˆœëŒ€êµ­', 'ê¹€ë°¥', 'ë–¡ë³¶ì´', 'ë¶„ì‹', 'ìƒëŸ¬ë“œë°”','ë§ˆë¼íƒ•', 'ë§ˆë¼ìƒ¹ê¶ˆ', 'ì¡±ë°œë³´ìŒˆ', 'ê³±ì°½ì „ê³¨', 'ìˆœëŒ€ë³¶ìŒ', 'ê¹€ë°¥ì²œêµ­', 'ë–¡ë³¶ì´ì§‘', 'ë¶ì–´êµ­', 'ìˆœë‘ë¶€ì°Œê°œ', 'ê¹€ì¹˜ì°Œê°œ', 'ëœì¥ì°Œê°œ', 'ë¹„ë¹”ë°¥', 'ë¶ˆê³ ê¸°', 'ê°ˆë¹„íƒ•', 'ìœ¡íšŒë¹„ë¹”ë°¥', 'ëƒ‰ë©´ì§‘', 'ì¹¼êµ­ìˆ˜ì§‘', 'ì•„ë©”ë¦¬ì¹¸ íŠ¸ë ˆì¼ëŸ¬','ì œë©´ì†Œ','ìš°ë¦¬ìŒì‹','ë§ˆë§ˆì¿¡'],
            'ìˆ ': ['ìˆ ì§‘', 'í˜¸í”„', 'í¬ì°¨', 'ì´ìì¹´ì•¼', 'ë§‰ê±¸ë¦¬', 'ì†Œì£¼', 'ë§¥ì£¼', 'ì™€ì¸', 'ì¹µí…Œì¼', 'ìˆ ì§‘', 'ìˆ ì§‘/í˜¸í”„', 'í˜¸í”„ì§‘', 'í¬ì¥ë§ˆì°¨','ì£¼ë¥˜'],
            'ì»¤í”¼': ['ì¹´í˜', 'ì»¤í”¼', 'ìŠ¤íƒ€ë²…ìŠ¤', 'íˆ¬ì¸', 'ì´ë””ì•¼', 'ì»¤í”¼ì „ë¬¸ì ','ê³µì°¨', 'í…Œë¼ë¡œì‚¬', 'ë¸Œëœë“œì¹´í˜', 'ë„ˆì„¬ì¹´í˜', 'í¬ë ˆì•„ì°Œì˜¨', 'íƒì•¤íƒìŠ¤', 'ì¹´í˜ê¼¼ë§ˆ','ì¸í…”ë¦¬ì  ì‹œì•„', 'ì¹´í˜ë² ë„¤', 'ì»¤í”¼ë¹ˆ', 'í• ë¦¬ìŠ¤', 'ë¹½ë‹¤ë°©', 'ì»¤í”¼ìˆ', 'ì»¤í”¼ì „ë¬¸ì ', 'ë””ì €íŠ¸ì¹´í˜','í”„ë¦³ì¸ '],
            'ìŒë£Œ': ['ìŒë£Œ', 'ì£¼ìŠ¤', 'ìŠ¤ë¬´ë””', 'ì¥¬ìŠ¤', 'ì ¤ë¼ë˜', 'ë²¤ë”©ë¨¸ì‹ '],
            'ë°°ë‹¬': ['ë°°ë‹¬ì˜ë¯¼ì¡±', 'ìš”ê¸°ìš”', 'ì¿ íŒ¡ì´ì¸ ', 'ìš°ì•„í•œí˜•ì œë“¤', 'ë°°ë‹¬', 'í†µë‹­']
        },
        'êµí†µ': {
            'ëŒ€ì¤‘êµí†µ': ['ì§€í•˜ì² ', 'ë²„ìŠ¤', 'të¨¸ë‹ˆ', 'êµí†µì¹´ë“œ'],
            'íƒì‹œ': ['íƒì‹œ', 'ì¹´ì¹´ì˜¤íƒì‹œ'],
            'ìì „ê±°': ['ë”°ë¦‰ì´', 'í‚¥ê³ ì‰', 'ì”½ì”½', 'ë¹”'],
            'í‚¥ë³´ë“œ': ['í‚¥ë³´ë“œ']
        },
        'ìë™ì°¨': {
            'ì¶©ì „': ['ì£¼ìœ ì†Œ', 'ì£¼ìœ ', 'ì¶©ì „ì†Œ', 'ì¶©ì „', 'skì—ë„ˆì§€', 'gsì¹¼í…ìŠ¤', 's-oil', 'í˜„ëŒ€ì˜¤ì¼ë±…í¬'],
            'ì£¼ì°¨': ['ì£¼ì°¨ì¥', 'ì£¼ì°¨'],
            'ì„¸ì°¨': ['ì„¸ì°¨'],
            'ìˆ˜ë¦¬': ['ì •ë¹„', 'íƒ€ì´ì–´', 'ì—”ì§„ì˜¤ì¼'],
            'ì„¸ê¸ˆ': ['ìë™ì°¨ë³´í—˜', 'í•˜ì´íŒ¨ìŠ¤', 'í†µí–‰ë£Œ']
        },
        'ë¬¸í™”ìƒí™œ': {
            'ì—¬í–‰': ['ì—¬í–‰', 'í˜¸í…”', 'íœì…˜', 'ì—ì–´ë¹„ì•¤ë¹„', 'ì•„ê³ ë‹¤', 'ì•¼ë†€ì', 'ì—¬ê¸°ì–´ë•Œ', 'ì•„ì‹œì•„ë‚˜í•­ê³µ', 'ëŒ€í•œí•­ê³µ', 'ì§„ì—ì–´', 'í•­ê³µ', 'hilton', 'ííŠ¼', 'ë¦¬ì¡°íŠ¸', 'ê²ŒìŠ¤íŠ¸', 'design beyond', 'eb', 'suica', 'fukuoka', 'subway', 'airport', 'ê³µí•­', 'íœ´ê²Œì†Œ'],
            'ì˜í™”/ê³µì—°/ê²Œì„': ['cgv', 'ë©”ê°€ë°•ìŠ¤', 'ë¡¯ë°ì‹œë„¤ë§ˆ', 'ì˜í™”', 'ê³µì—°', 'ì½˜ì„œíŠ¸', 'ìŠ¤íŒ€', 'ë„·í”Œë¦­ìŠ¤', 'ì™“ì± ', 'ë””ì¦ˆë‹ˆ'],
            'ìŒì•…/ë„ì„œ': ['ìŒì•…', 'ë„ì„œ', 'ì±…', 'ì˜í’ë¬¸ê³ ', 'êµë³´ë¬¸ê³ ', 'ì•Œë¼ë”˜', 'ì¸í„°íŒŒí¬ë„ì„œ', 'yes24', 'ë°˜ë””ì•¤ë£¨ë‹ˆìŠ¤', 'ì˜í™”ì˜ˆë§¤', 'ê³µì—°ì˜ˆë§¤'],
            'ì–´í”Œ': ['ì• í”Œ', 'êµ¬ê¸€í”Œë ˆì´', 'ì•±ìŠ¤í† ì–´', 'ì•±', 'ì–´í”Œ', 'êµ¬ë…', 'ì¸ì•±ê²°ì œ', 'ì¸ì•±'],
            'ìº í•‘': ['ìº í•‘'],
            'ì˜¨ì²œ/ë§ˆì‚¬ì§€': ['ì˜¨ì²œ', 'ë§ˆì‚¬ì§€', 'ìŠ¤íŒŒ']
        },
        'íŒ¨ì…˜/ë¯¸ìš©': {
            'ì˜ë¥˜': ['ìœ ë‹ˆí´ë¡œ', 'ìë¼', 'ë¬´ì‹ ì‚¬', 'ì˜·', 'ì‹ ë°œ', 'ê°€ë°©', 'h&m', 'ìŠ¤íŒŒì˜¤', 'íƒ‘í…', 'ì§€ì˜¤ë‹¤ë…¸', 'ë‚˜ì´í‚¤', 'ì•„ë””ë‹¤ìŠ¤', 'ì¹¼í•˜íŠ¸', 'ì´ëœë“œ', 'ë¸Œë¼ë”ìŠ¤ìŠ¤í† ì–´', 'íŒŒíƒ€ê³ ë‹ˆì•„', 'ì•„ì´ê°“ì—ë¸Œë¦¬ëµ'],
            'í™”ì¥í’ˆ': ['ì˜¬ë¦¬ë¸Œì˜', 'ì´ë‹ˆìŠ¤í”„ë¦¬', 'í™”ì¥í’ˆ', 'ì—ë›°ë“œ', 'ë¯¸ìƒ¤', 'ì„¸í¬ë¼', 'ì•„ëª¨ë ˆí¼ì‹œí”½', 'ë² ë„¤í”¼íŠ¸', 'ì—˜ì§€ìƒí™œê±´ê°•', 'ìƒ´í‘¸', 'í¬ë¹„ë¸Œë¼ì´íŠ¸', 'ë¸”ë£¨ì¥¬ì–¼ë¦¬'],
            'í—¤ì–´': ['ì†ë³´ì—°','ë¯¸ìš©ì‹¤', 'í—¤ì–´ìƒµ', 'ì— ì—ì´ì¹˜ì•¤ì½”ëª¨ë˜', 'í—¤ì–´ìƒµ', 'ë¯¸ìš©ì‹¤', 'ë„¤ì¼ìƒµ', 'ë„¤ì¼ì•„íŠ¸', 'ì†ëˆˆì¹ì—°ì¥', 'ì™ì‹±'],
            'ì„¸íƒ': ['ì„¸íƒì†Œ']
        },
        'ìƒí™œìš©í’ˆ': {
            'ê°€êµ¬/ê°€ì „': ['ë‹¤ì´ì†Œ', 'ì´ì¼€ì•„', 'ì½”ìŠ¤íŠ¸ì½”', 'ì „ìì œí’ˆ', 'ê°€ì „', 'ê°€êµ¬', 'í•˜ì´ë§ˆíŠ¸', 'ì „ìëœë“œ', 'ì‚¼ì„±ë””ì§€í„¸í”„ë¼ì'],
            'ì£¼ë°©/ìš•ì‹¤': ['ì£¼ë°©', 'ìš•ì‹¤'],
            'ì¡í™”': ['ì¿ íŒ¡', '11ë²ˆê°€', 'gë§ˆì¼“', 'ì˜¥ì…˜', 'ë„¤ì´ë²„ì‡¼í•‘', 'ë”í˜„ëŒ€', 'ì‹ ì„¸ê³„',  'ë¡¯ë°ì‡¼í•‘', 'ì•„ìš¸ë ›', 'í˜„ëŒ€ë°±í™”ì ', 'ë°±í™”ì ']
        },
        'ì£¼ê±°/í†µì‹ ': {
            'ê´€ë¦¬ë¹„': ['ê´€ë¦¬ë¹„', 'ì•„íŒŒíŠ¸'],
            'ê³µê³¼ê¸ˆ': ['ì „ê¸°', 'ê°€ìŠ¤', 'ìˆ˜ë„', 'ê³µê³¼ê¸ˆ', 'ë„ì‹œê°€ìŠ¤', 'ì—ë„ˆì§€ê³µì‚¬', 'ì„œìš¸ì—ë„ˆì§€'],
            'í†µì‹ ë¹„': ['kt', 'skt', 'lgìœ í”ŒëŸ¬ìŠ¤', 'ì¸í„°ë„·', 'í•¸ë“œí°', 'íœ´ëŒ€í°', 'í†µì‹ ', 'lgì „ì', 'êµ¬ë…ë£Œ'],
            'ì´ìì›”ì„¸': ['ì›”ì„¸', 'ì´ì','ëŒ€ì¶œìƒí™˜', 'ëŒ€ì¶œ', 'ìƒí™˜']
        },
        'ê²½ì¡°ì‚¬': {
            'ê²°í˜¼/ë¶€ê³ ': ['ì¶•ì˜ê¸ˆ', 'ë¶€ì˜ê¸ˆ', 'ê²°í˜¼ì‹', 'ì¥ë¡€ì‹'],
            'ì„ ë¬¼': ['ì„ ë¬¼', 'í™”í™˜'],
            'í—Œê¸ˆ': ['í—Œê¸ˆ', 'ì¡°ê³„ì¢…', 'ì¡°ê³„ì‚¬', 'ë¶ˆêµ', 'êµíšŒ', 'ì„±ë‹¹'],
            'ì˜ˆì‹': ['ì˜ˆì‹', 'ëŒì”ì¹˜', 'ë°±ì¼']
        },
        'ê±´ê°•': {
            'ìš´ë™': ['ê¹€ì›', 'í•„ë¼í…ŒìŠ¤', 'í—¬ìŠ¤ì¥', 'ì²´ìœ¡ê´€', 'ìš”ê°€', 'í”¼íŠ¸ë‹ˆìŠ¤', 'ìš´ë™', 'pt', 'í¼ìŠ¤ë„íŠ¸ë ˆì´ë‹'],
            'ë³‘ì›': ['ë³‘ì›', 'ì˜ì›', 'í•œì˜ì›', 'ì¢…í•©ë³‘ì›', 'ëŒ€í•™ë³‘ì›', 'ë‚´ê³¼', 'ì™¸ê³¼', 'ì´ë¹„ì¸í›„ê³¼', 'ì •ì‹ ê³¼', 'ì‚°ë¶€ì¸ê³¼', 'ì†Œì•„ê³¼', 'ë¹„ë‡¨ê¸°ê³¼', 'ì‹ ê²½ê³¼', 'ì‹¬ë¦¬ìƒë‹´'],
            'ë³´í—˜': ['ë³´í—˜', 'ì¹˜ê³¼', 'ì•ˆê³¼', 'ì •í˜•ì™¸ê³¼', 'í”¼ë¶€ê³¼']
        },
        'íˆ¬ì': {
            'ì„œë¹„ìŠ¤': ['ì¦ê¶Œ', 'ì£¼ì‹', 'í€ë“œ', 'ì ê¸ˆ', 'ì˜ˆê¸ˆ', 'ì—°ê¸ˆ', 'í‡´ì§ê¸ˆ', 'íˆ¬ì']
        }
    }


    # í‚¤ì›Œë“œ ë§¤ì¹­ìœ¼ë¡œ ë¶„ë¥˜ (ëŒ€ì†Œë¬¸ì ë¬´ì‹œ)
    for category, subcategory_dict in keyword_mapping.items():
        for subcategory, keywords in subcategory_dict.items():
            for keyword in keywords:
                if keyword.lower() in description_clean:
                    return category, subcategory

    return 'ê¸°íƒ€', 'ê¸°íƒ€'

def main():
    """ë©”ì¸ í•¨ìˆ˜"""
    print("ğŸ›’ ì†Œë¹„ë‚´ì—­ ë¶„ë¥˜ê¸° v2.0 (ê°œì„ ëœ í‚¤ì›Œë“œ)")
    print("=" * 60)

    # ë¶„ë¥˜ ê·œì¹™ ë¡œë“œ
    try:
        rules = load_classification_rules()
        print("âœ… ë¶„ë¥˜ê¸°ì¤€.json ë¡œë“œ ì™„ë£Œ")
    except Exception as e:
        print(f"âŒ ë¶„ë¥˜ê¸°ì¤€.json ë¡œë“œ ì‹¤íŒ¨: {e}")
        return

    # ì†Œë¹„ë‚´ì—­ íŒŒì¼ ì½ê¸° (xlsx ë˜ëŠ” csv)
    try:
        try:
            df = pd.read_excel('ì†Œë¹„ë‚´ì—­.xlsx')
            print(f"âœ… ì†Œë¹„ë‚´ì—­.xlsx íŒŒì¼ ë¡œë“œ ì™„ë£Œ ({len(df):,}ê±´)")
        except:
            df = pd.read_csv('ì†Œë¹„ë‚´ì—­.csv', encoding='utf-8-sig')
            print(f"âœ… ì†Œë¹„ë‚´ì—­.csv íŒŒì¼ ë¡œë“œ ì™„ë£Œ ({len(df):,}ê±´)")
    except Exception as e:
        print(f"âŒ ì†Œë¹„ë‚´ì—­ íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨: {e}")
        return

    # ë°ì´í„° ì „ì²˜ë¦¬
    print("\nğŸ“Š ë°ì´í„° ì „ì²˜ë¦¬ ì¤‘...")

    # ì´ìš©ê¸ˆì•¡ì„ ìˆ«ìë¡œ ë³€í™˜
    df['ê¸ˆì•¡'] = df['ì´ìš©ê¸ˆì•¡'].astype(str).str.replace(',', '').str.replace('ì›', '')
    df['ê¸ˆì•¡'] = pd.to_numeric(df['ê¸ˆì•¡'], errors='coerce').fillna(0)

    # ë¹ˆ ê°’ ì²˜ë¦¬
    df['ì—…ì¢…'] = df['ì—…ì¢…'].fillna('')
    df['ì´ìš©ê°€ë§¹ì '] = df['ì´ìš©ê°€ë§¹ì '].fillna('')

    # ë¶„ë¥˜ ì§„í–‰
    print("ğŸ” ê±°ë˜ ë¶„ë¥˜ ì¤‘...")
    categories = []
    subcategories = []

    for idx, row in df.iterrows():
        category, subcategory = classify_transaction(
            row['ì´ìš©ê°€ë§¹ì '],
            row['ì—…ì¢…'],
            rules
        )
        categories.append(category)
        subcategories.append(subcategory)

    # ë‚ ì§œ í˜•ì‹ ì²˜ë¦¬
    if df['ì´ìš©ì¼ì'].dtype == 'object':
        df['ì´ìš©ì¼ì'] = pd.to_datetime(df['ì´ìš©ì¼ì'], format='%Y.%m.%d', errors='coerce')

    # ê²°ê³¼ DataFrame ìƒì„±
    result_df = pd.DataFrame({
        'ë‚ ì§œ': df['ì´ìš©ì¼ì'].dt.strftime('%Y-%m-%d'),
        'ì‹œê°„': df['ì´ìš©ì‹œê°„'],
        'ìì‚°': df['ì´ìš©ì¹´ë“œ'],
        'ë¶„ë¥˜': categories,
        'ì†Œë¶„ë¥˜': subcategories,
        'ê¸ˆì•¡(ì›)': df['ê¸ˆì•¡'].abs(),
        'í™”íêµ¬ë¶„': 'KRW',
        'ë‚´ìš©': df['ì´ìš©ê°€ë§¹ì '],
        'ë©”ëª¨': df['ì—…ì¢…']
    })

    # ë‚ ì§œìˆœ ì •ë ¬
    result_df = result_df.sort_values('ë‚ ì§œ', ascending=False)

    # CSVë¡œ ì €ì¥
    output_filename = f'ìµœì¢…_ë¶„ë¥˜ëœ_ì†Œë¹„ë‚´ì—­_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv'
    result_df.to_csv(output_filename, index=False, encoding='utf-8-sig')

    print(f"\n" + "=" * 60)
    print(f"âœ… ë¶„ë¥˜ ì™„ë£Œ!")
    print(f"ğŸ“Š ì´ ê±°ë˜ ìˆ˜: {len(result_df):,}ê°œ")
    print(f"ğŸ’° ì´ ê¸ˆì•¡: {result_df['ê¸ˆì•¡(ì›)'].sum():,.0f}ì›")
    print(f"ğŸ“… ê¸°ê°„: {result_df['ë‚ ì§œ'].min()} ~ {result_df['ë‚ ì§œ'].max()}")
    print(f"ğŸ’¾ ì €ì¥ëœ íŒŒì¼: {output_filename}")

    # ë¶„ë¥˜ë³„ ìš”ì•½
    print(f"\nğŸ“ˆ ë¶„ë¥˜ë³„ ìš”ì•½:")
    category_summary = result_df.groupby('ë¶„ë¥˜')['ê¸ˆì•¡(ì›)'].agg(['sum', 'count'])
    category_summary = category_summary.sort_values('sum', ascending=False)

    for category, row in category_summary.iterrows():
        print(f"   {category}: {row['sum']:,.0f}ì› ({int(row['count'])}ê±´)")

    # ì†Œë¶„ë¥˜ë³„ ìš”ì•½ (ìƒìœ„ 15ê°œ)
    print(f"\nğŸ·ï¸ ì†Œë¶„ë¥˜ë³„ ìš”ì•½ (ìƒìœ„ 15ê°œ):")
    subcategory_summary = result_df.groupby('ì†Œë¶„ë¥˜')['ê¸ˆì•¡(ì›)'].agg(['sum', 'count'])
    subcategory_summary = subcategory_summary.sort_values('sum', ascending=False).head(15)

    for subcategory, row in subcategory_summary.iterrows():
        print(f"   {subcategory}: {row['sum']:,.0f}ì› ({int(row['count'])}ê±´)")

    # ìì‚°ë³„ ìš”ì•½
    print(f"\nğŸ’³ ìì‚°ë³„ ìš”ì•½:")
    asset_summary = result_df.groupby('ìì‚°')['ê¸ˆì•¡(ì›)'].agg(['sum', 'count'])
    asset_summary = asset_summary.sort_values('sum', ascending=False)

    for asset, row in asset_summary.iterrows():
        print(f"   {asset}: {row['sum']:,.0f}ì› ({int(row['count'])}ê±´)")

    # ê¸°íƒ€ ë¶„ë¥˜ê°€ ì–¼ë§ˆë‚˜ ë‚¨ì•˜ëŠ”ì§€ í™•ì¸
    others_count = len(result_df[result_df['ë¶„ë¥˜'] == 'ê¸°íƒ€'])
    others_amount = result_df[result_df['ë¶„ë¥˜'] == 'ê¸°íƒ€']['ê¸ˆì•¡(ì›)'].sum()
    print(f"\nâ“ ê°œì„  ê²°ê³¼:")
    print(f"   'ê¸°íƒ€' ë¶„ë¥˜: {others_count}ê±´ ({others_amount:,.0f}ì›)")
    print(f"   ë¶„ë¥˜ ì •í™•ë„: {((len(result_df) - others_count) / len(result_df) * 100):.1f}%")

if __name__ == "__main__":
    main()
```
