# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a Next.js frontend application for a Korean blog called "꿈의 일환" (Part of a Dream). It uses MDX files with Contentlayer for content management, featuring Korean localization, mobile-responsive design, and enhanced markdown content rendering with syntax highlighting.

## Development Commands

```bash
# Development server with hot reload
npm run dev

# Production build (includes Contentlayer generation)
npm run build

# Start production server
npm run start

# Run ESLint checks
npm run lint

# Quick deploy command (lint, build, commit, push)
npm run deploy

# Generate Contentlayer files manually (if needed)
npx contentlayer2 build
```

## Technology Stack

- **Framework**: Next.js 15.3.3 with App Router
- **React**: Version 19 with Server Components
- **TypeScript**: Strict type checking enabled with ES2020 target and baseUrl configuration
- **Content Management**: Contentlayer2 with MDX support
- **Styling**: Tailwind CSS v4
- **Database**: Supabase with PostgreSQL for comment system
- **Markdown Enhancement**: 
  - `@mdx-js/react` and `@mdx-js/loader` for MDX processing
  - `rehype-pretty-code` with Shiki for syntax highlighting
  - `rehype-slug` and `rehype-autolink-headings` for enhanced navigation
- **Image Optimization**: Next.js Image component with automatic WebP conversion and lazy loading
- **Date Handling**: dayjs for Korean localization
- **Font**: Pretendard Variable for Korean text optimization (loaded via CDN)

## Content Management Architecture

The application uses a **file-based content management system** with Contentlayer:

1. **Content Directory**: `./content/` contains all MDX files
2. **Static Generation**: Contentlayer processes MDX at build time
3. **Type Safety**: Generated TypeScript interfaces from Contentlayer schema
4. **No External Dependencies**: No CMS or API calls required

### Content Structure

```
content/
├── posts/
│   ├── hello-world.mdx
│   └── nextjs-tips.mdx
└── profile.mdx
```

### Contentlayer Configuration

Defined in `contentlayer.config.js` with two document types:

- **BlogPost**: Files in `posts/**/*.mdx` with required fields (title, publishedAt) and optional fields (description, tags)
  - **Computed Field**: `slug` - automatically generated from file path
- **Profile**: Single `profile.mdx` file with title, biography, and contact information

## TypeScript Interfaces

Content interfaces are generated by Contentlayer and available from `.contentlayer/generated`. Main interfaces defined in `src/lib/content.ts`:

```typescript
interface BlogPost {
  documentId: string;
  slug: string;
  title: string;
  content: string;
  publishedAt: string;
  description?: string;
  tags?: string[];
  comments?: Comment[];
  body: {
    raw: string;
    code: string; // Pre-compiled MDX code
  };
}

interface Profile {
  title: string;
  biography: string;
  contact: {
    email?: string;
    linkedin?: string;
    github?: string;
  } | string | null;
  body: {
    raw: string;
    code: string;
  };
}
```

**Key Content Functions** (exported from `src/lib/content.ts`):
- `getBlogPosts()`: Returns all blog posts sorted by publication date
- `getPostWithDetails(slug)`: Returns post, adjacent posts, and comments from Supabase
- `getProfile()`: Returns profile information from profile.mdx

## Component Architecture

Components are organized by feature:

```
src/components/
├── layout/           # Page layout and navigation
├── post/             # Blog post components (PostCard, MDXRenderer, PostNavigation)
├── comment/          # Supabase-powered comment system components
├── common/           # Shared utilities (RelativeTime)
└── ui/               # Base UI components (Button, Input, Textarea) with shared formStyles
```

### Key Components

- **PostCard**: Unified component for blog posts and placeholder states
- **MDXRenderer**: Renders pre-compiled MDX using `useMDXComponent` hook
- **RelativeTime**: Korean date formatting with absolute/relative display options
- **Form Components**: Consistent styling via `formStyles.ts` utility

## Rendering Strategy

- **Static Site Generation**: All content is statically generated at build time
- **Server Components**: Posts and profile data are fetched server-side
- **Client Components**: Interactive elements and MDX content rendering
- **No Runtime API Calls**: All content comes from pre-processed files

## Routing Strategy

- **Dynamic Routes**: `/posts/[id]` where `id` is the post slug
- **Slug Generation**: Contentlayer strips `posts/` prefix from file paths
- **Static Generation**: `generateStaticParams` creates routes for all posts at build time

## MDX Processing Pipeline

1. **Build Time**: Contentlayer processes MDX files with rehype plugins
2. **Syntax Highlighting**: `rehype-pretty-code` with Shiki (github-dark/light themes)
3. **Navigation**: `rehype-slug` and `rehype-autolink-headings` for anchor links
4. **Compilation**: MDX compiled to executable JavaScript code
5. **Runtime**: `useMDXComponent` renders pre-compiled code

## Design System

- **Styling**: Tailwind CSS v4 with CSS-first approach
- **Dark Mode**: Full support with CSS variables and system detection
- **Typography**: Custom prose styles for MDX content via `@tailwindcss/typography`
- **Responsive Design**: Mobile-first with Tailwind breakpoints
- **Color System**: OKLCH color space for better accuracy
- **Patterns**: Dot-pattern backgrounds with automatic dark mode variants

### Layout Constraints

- **Homepage Grid**: 6-row maximum display with `overflow-hidden`
  - Mobile: `max-h-[1008px]` (6 × 168px per PostCard)
  - Desktop: `max-h-[960px]` (6 × 160px per PostCard)
  - Uses `flex-wrap` to maintain responsive column behavior

## Next.js 15 Compatibility

- **Dynamic Route Params**: `params` must be awaited in page components
- **Contentlayer Integration**: `withContentlayer()` wrapper in `next.config.ts`
- **TypeScript Configuration**: ES2020 target with `baseUrl: "."` required for Contentlayer imports

## Environment Configuration

**Required Environment Variables**:

```bash
# Supabase Configuration (required for comment system)
NEXT_PUBLIC_SUPABASE_URL=your_supabase_project_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
```

**Previous Variables** (no longer needed):
```bash
# NEXT_PUBLIC_STRAPI_URL
# REVALIDATE_TOKEN
```

## Deployment

**Automated via GitHub Actions**:
- Pushes to main branch trigger automatic Vercel deployment
- Workflow includes linting and build verification with Node.js 18
- Requires GitHub Secrets: `VERCEL_TOKEN`, `ORG_ID`, `PROJECT_ID`

**Manual Vercel Deployment**:
- Import GitHub repository at https://vercel.com/new
- Configure Supabase environment variables for comment functionality

## Code Quality & Build Requirements

**Pre-commit Checklist**:

```bash
npm run lint    # Fix all ESLint errors (warnings OK)
npm run build   # Ensure production build succeeds
```

**Common Build Issues**:
- Contentlayer generation errors if MDX frontmatter is invalid
- TypeScript errors from missing required MDX fields
- Import errors if `.contentlayer/generated` is not properly included in tsconfig

**TypeScript Path Configuration**:
- Contentlayer imports use `contentlayer/generated` alias (configured in `tsconfig.json`)
- This eliminates Contentlayer import warnings about missing path aliases

## Comment System Architecture

**Supabase-Powered Comment System**: Fully functional comment system with optimized API calls and real-time updates.

### Database Schema
Comments table structure:
```sql
CREATE TABLE comments (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  post_slug VARCHAR(255) NOT NULL,
  author_name VARCHAR(100) NOT NULL,
  author_email VARCHAR(255) NOT NULL,
  content TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### Key Functions (`src/lib/content.ts`):
- `getComments(postSlug)`: Retrieves comments for a specific post
- `createComment(commentData)`: Creates new comment with optimistic updates
- `updateComment(commentId, updates)`: Updates existing comment
- `deleteComment(commentId)`: Deletes comment with email verification

### Performance Optimizations:
- **Optimistic Updates**: New comments appear immediately in UI
- **Minimal API Calls**: Prevents duplicate fetching on component initialization
- **Email Verification**: Edit/delete requires author email confirmation
- **Error Handling**: Graceful fallbacks and user feedback

### Component Architecture:
- **CommentSection**: Main container with optimized state management
- **CommentForm**: Form with optimistic update support
- **CommentList**: Display and management with edit/delete functionality

## SEO & Metadata System

### Shared Metadata Utilities

Centralized metadata system in `src/lib/metadata.ts`:

```typescript
import { createMetadata } from "@/lib/metadata";

export const metadata = createMetadata({
  title: "Page Title",
  description: "Page description",
  keywords: ["additional", "keywords"],
  type: "article" | "website" | "profile"
});
```

### SEO Features

- **Dynamic Sitemap**: Auto-generates sitemap.xml from Contentlayer data
- **Structured Data**: JSON-LD schemas for Article and Person types
- **Open Graph & Twitter Cards**: Social media preview optimization
- **Korean Language**: Proper `lang="ko"` declaration

## Development Guidelines

### Adding New Content

**Blog Posts**: Create new `.mdx` files in `content/posts/` with required frontmatter:

```yaml
---
title: "Post Title"
publishedAt: "2024-01-01"
description: "Optional description"
tags: ["tag1", "tag2"]
---
```

**Profile Updates**: Edit `content/profile.mdx` with required fields (title, biography, career).

### MDX Content Guidelines

- Use standard Markdown syntax with React component support
- Code blocks automatically get syntax highlighting
- Headings automatically receive anchor links
- Images should use descriptive alt text for accessibility

### Image Handling in MDX

**MDXRenderer** automatically enhances images with:
- **Next.js Image Component**: Automatic optimization, lazy loading, WebP conversion
- **Alt Text Display**: Image descriptions appear as styled captions below images
- **Responsive Design**: Images automatically scale to container width
- **External vs Local**: External images use `unoptimized` flag, local images get full optimization

```markdown
# External images (automatically optimized)
![Description](https://example.com/image.jpg)

# Local images (store in public/images/)
![Description](/images/my-image.jpg)
```

### Metadata Implementation

Always use the shared `createMetadata` utility for consistent SEO optimization across pages.

### Time Display

Use `RelativeTime` component for consistent Korean date formatting:

```tsx
<RelativeTime dateString={post.publishedAt} absolute />  // "6월 22일 금요일"
<RelativeTime dateString={post.publishedAt} />          // "2일 전"
```

## Key Architectural Decisions

### Migration from Strapi to Contentlayer + Supabase

**Benefits Achieved**:
- **Hybrid Architecture**: Static content via Contentlayer + dynamic comments via Supabase
- **Enhanced Performance**: Static generation for content, optimized API calls for comments
- **Better Developer Experience**: Type-safe content with local file editing and PostgreSQL reliability
- **Cost Optimization**: Reduced API calls through optimistic updates and smart caching
- **Improved Reliability**: No CMS dependencies for content, robust database for user interactions

### Korean Localization Architecture

- **Date Formatting**: dayjs with Korean locale for relative/absolute time display
- **Content Strategy**: Korean-first interface with proper typography and spacing
- **Font Optimization**: Pretendard Variable via CDN for optimal Korean text rendering

### Performance Optimizations

- **Removed Computed URL Field**: Eliminated redundant `url` computed field from Contentlayer, using slug-based URL generation instead
- **Image Optimization**: Next.js Image component with automatic format conversion and lazy loading
- **Static Generation**: All content pre-rendered at build time with no runtime API dependencies
- **Optimistic Updates**: Comments appear immediately in UI, reducing perceived loading time
- **API Call Minimization**: Single initialization pattern prevents duplicate database queries
- **Smart State Management**: useEffect dependencies optimized to prevent unnecessary re-renders

### Comment System Implementation Patterns

**Optimistic Update Pattern**:
```typescript
// Add comment immediately to UI, then sync with database
const handleCommentAdded = (newComment?: Comment) => {
  if (newComment) {
    setComments(prev => [...prev, newComment]); // Immediate UI update
  } else {
    fetchComments(); // Fallback for errors
  }
};
```

**Initialization Guard Pattern**:
```typescript
// Prevent duplicate API calls during component initialization
const [hasInitialized, setHasInitialized] = useState(false);
useEffect(() => {
  if (hasInitialized) return;
  // initialization logic
  setHasInitialized(true);
}, [postSlug]);
```